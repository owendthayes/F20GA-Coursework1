<!doctype html>

<html>
    <head>
        <meta charset="utf-8">
        <title>2024-2025 F2XGA: Example 01 - Hello WebGPU</title>
</head>

<body>
    <canvas width="512" height="512"></canvas>

    <script type="module">
        // Note: type module is needed for top-level awaits (e.g. awaits outside of async functions)
 
        // Graphics are quite difficult to debug (blank screen) - so adding debugging messages.
        console.log("Starting WebGPU code (" + Date().toLocaleString() + ").");

        //import loader
        import Loader from './Loader.js';
 
        async function main() {

            console.log("Checking for support, hardware and adapter.");
            if (!navigator.gpu) {
                throw new Error("WebGPU not supported by your browser.");
            }

            const adapter = await navigator.gpu.requestAdapter();
            if (!adapter){
                throw new Error("WebGPU Supported but not appropriate hardware.");
            }

            const device = await adapter.requestDevice();
            if (!device) {
                throw new Error("Error supporting WebGPU in your browser");
            }

            console.log("Getting the WebGPU context from our canvas element and configuring it.");
            const canvas = document.querySelector('canvas');
            const context = canvas.getContext('webgpu');
            const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
            context.configure({
                device,
                format: canvasFormat,
            });
            
            const vsShaderCode = `
                @vertex fn vs(
                @builtin(vertex_index) vertexIndex : u32
                ) -> @builtin(position) vec4f {
                    let pos = array(
                        vec2f(-0.5,  0.5),  // top left
                        vec2f(-0.5, -0.5),  // bottom left
                        vec2f( 0.5,  0.5),  // top right
                        vec2f(-0.5,  0.5)  // top left
                    );
            
                    return vec4f(pos[vertexIndex], 0.0, 1.0);
                }
            
                @fragment fn fs() -> @location(0) vec4f {
                    return vec4f(0.0, 0.0, 0.7, 1.0);
                }`;

            const fsShaderCode = `
                @fragment fn fs() -> @location(0) vec4f {
                        return vec4f(0.0, 0.0, 1.0, 1.0); //blue color
                    }`;

            //create shaders
            const vsModule = device.createShaderModule({ code: vsShaderCode });
            const fsModule = device.createShaderModule({ code: fsShaderCode });


            const pipeline = device.createRenderPipeline({
                label: 'pipeline',
                vertex: {
                    module: vsModule,
                    entryPoint: 'vs',
                    buffers: [{
                        arrayStride: 2 * 4,
                        attributes: [
                            {shaderLocation: 0, format: 'float32x2', offset: 0},
                        ],
                    }],
                },
                fragment: {
                    module: fsModule,
                        entryPoint: 'fs',
                        targets: [{
                            format: canvasFormat,
                        }],
                },
                primitive: {
                    topology: 'triangle-strip',
                    stripIndexFormat: 'uint16',
                },
                layout: 'auto',
            });

            //load object
            const loader = new Loader();
            const objFile = await loader.load('meshes/testCube.obj');
            //load materials in later
            //const mtlFile = await loader.load('meshes/testCube.mtl');

            const parsedObject = loader.parse(objFile);
            const positions = parsedObject.positions;
            const indices = parsedObject.indices;

            //buffer for object position and indices
            const vertexBuffer = device.createBuffer({
                    size: positions.byteLength,
                    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                });
                device.queue.writeBuffer(vertexBuffer, 0, positions);

                const indexBuffer = device.createBuffer({
                    size: indices.byteLength,
                    usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
                });
                device.queue.writeBuffer(indexBuffer, 0, indices);


            const renderPassDescriptor = {
                label: 'Basic canvas render pass',
                colorAttachments: [
                {
                    view: context.getCurrentTexture().createView(),
                    // view: <- to be filled out when we render
                    clearValue: { r: 0.0, g: 0.0, b: 0.7, a: 1.0 }, // Clear to blue
                    loadOp: 'clear',  // clear or store (draw on top)
                    storeOp: 'store', // store or clear (throw away - e.g. multisampling)
                },
                ],
            };


            function render() {
                console.log("Rendering frame (" + Date().toLocaleString() + ").");

                // Get the current texture from the canvas context and set it as the texture to render.
                //renderPassDescriptor.colorAttachments[0].view =
                //    context.getCurrentTexture().createView();

                // Create a command encoder to start encoding commands
                const encoder = device.createCommandEncoder({ label: 'the encoder' });
                // Create a render pass encoder to encode render commands
                const pass = encoder.beginRenderPass(renderPassDescriptor);
                pass.setPipeline(pipeline);
                pass.setVertexBuffer(0, vertexBuffer);
                pass.setIndexBuffer(indexBuffer, 'uint16');
                pass.drawIndexed(indices.length);
                //finish encoding pass
                pass.end();

                const commandBuffer = encoder.finish();
                
                device.queue.submit([commandBuffer]);
            }
            render();   
        } 
        main();
    </script>

</body>
</html>