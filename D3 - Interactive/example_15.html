<!doctype html>

<html>
    <head>
        <meta charset="utf-8">
        <title>2024-2025 F2XGA: Example 15 - textures</title>
        <script src="libraries/jquery-3.7.1.min.js"></script>
        <script src="https://wgpu-matrix.org/dist/3.x/wgpu-matrix.js"></script>
</head>

<style>
    html, body {
      margin: 0;       /* remove the default margin          */
      height: 100%;    /* make the html,body fill the page   */
    }
    canvas {
      display: block;  /* make the canvas act like a block   */
      width: 100%;     /* make the canvas fill its container */
      height: 100%;
    }
</style>

<body>
    <canvas id="canvasElement"></canvas>

    <script type="module">
        // Note: type module is needed for top-level awaits (e.g. awaits outside of async functions)
 
        // Variables
        const { vec2, vec3, mat4 } = wgpuMatrix;    // Needed to define elements from wgpu-matrix library

        let adapter;
        let device;
        let canvas;
        let canvasWidth;        
        let canvasHeight;       
        let context;
        let canvasFormat;
        let vsShaderFile;
        let fsShaderFile;
        let vsModule;
        let fsModule;
        let vertexBuffer;   
        let colorBuffer;  
        let textureBuffer;  // New  
        let indexBuffer; 
        let bindGroupLayout;    
        let pipelineLayout;     
        let translations = [];                  
        let bindGroups = [];                    
        let uniformBufferTransformations = [];     
        let uniformBufferProjection;    
        let uniformBufferView;      
        let modelMatrices = [];                   
        let viewMatrix;                      
        let projectionMatrix;           
        let angle = 0.0;              
        let pipeline;
        let renderPassDescriptor;
        let then = Date.now();
        let now = 0;                
        let canvasElement; 
        let depthStencilTexture;   
        let depthStencilState;         
        let depthStencilView;       
        let depthStencilAttachment; 
        let noCubes = 10;          
        let cameraPosition = vec3.create(0.0, 0.0, 20.0);       
        let cameraFront = vec3.create(0.0, 0.0, -1.0);           
        let cameraUp = vec3.create(0.0, 1.0, 0.0);              
        let cameraSpeed = 0.5;                                   
        let keys = {};   
        let texture;     // new                                             


        
      
        // Graphics are quite difficult to debug (blank screen) - so adding debugging messages.
        console.log("Starting WebGPU code (" + Date().toLocaleString() + ").");
 
        async function main() {

            async function setup(){
                console.log("Checking for support, hardware and adapter.");
                if (!navigator.gpu) {
                    throw new Error("WebGPU not supported by your browser.");
                }

                adapter = await navigator.gpu.requestAdapter();
                if (!adapter){
                    throw new Error("WebGPU Supported but not appropriate hardware.");
                }

                device = await adapter.requestDevice();
                if (!device) {
                    throw new Error("Error supporting WebGPU in your browser");
                }

                console.log("Getting the WebGPU context from our canvas element and configuring it.");
                canvas = document.querySelector('canvas');
                context = canvas.getContext('webgpu');
                canvasFormat = navigator.gpu.getPreferredCanvasFormat();
                context.configure({
                    device,
                    format: canvasFormat,
                    alphaMode: 'premultiplied',         // new: alphaMode
                });

            } 

            function create_pipeline(){{
                // separate function to create the pipeline as it needs to be redone is screen is resized.
                console.log("Create structures for depth comparison...");
                depthStencilState = {
                    format: 'depth24plus-stencil8',
                    depthWriteEnabled: true,
                    depthCompare: 'less-equal',
                };

                depthStencilTexture = device.createTexture({
                    size: { width: canvasWidth, height: canvasHeight, depthOrArrayLayers: 1 },
                    format: 'depth24plus-stencil8',
                    usage: GPUTextureUsage.RENDER_ATTACHMENT 
                });

                depthStencilView = depthStencilTexture.createView({
                    format: 'depth24plus-stencil8',
                    dimension: '2d',    
                    aspect: 'all',
                });

                depthStencilAttachment = {
                    view: depthStencilView,
                    depthClearValue: 1.0,
                    depthLoadOp: 'clear',
                    depthStoreOp: 'store',
                    stencilLoadOp: 'clear',
                    stencilStoreOp: 'discard',
                };

                console.log('Creating pipeline ...');
                pipeline = device.createRenderPipeline({
                    label: 'Hardcoded pipeline',
                    layout: pipelineLayout,
                    vertex: {
                        module: vsModule,
                        entryPoint: 'vs',
                        buffers: [              
                            {                       // define  vbo
                                arrayStride: 3 * 4, //3x4bytes
                                attributes: [
                                    {shaderLocation: 0, offset:0 , format: 'float32x3'},
                                ],
                            },
                            {                       // define colors
                                arrayStride: 4 * 4, //4x4bytes
                                attributes: [
                                    {shaderLocation: 1, offset:0 , format: 'float32x4'},
                                ],
                            },                      // new
                            {                       // define texture coordinates
                                arrayStride: 2 * 4, //2x4bytes
                                attributes: [
                                    {shaderLocation: 2, offset:0 , format: 'float32x2'},
                                ],
                            }  
                        ],
                    },
                    fragment: {
                        module: fsModule,
                        entryPoint: 'fs',
                    targets: [{ 
                        format: canvasFormat,
                        blend: {
                            color: {
                                operation: 'add',
                                srcFactor: 'one',
                                dstFactor: 'one-minus-src-alpha',
                                
                            },
                            alpha: {
                                operation: 'add',
                                srcFactor: 'one',
                                dstFactor: 'one-minus-src-alpha',
                                
                            },
                        },
                    }],
                    },

                    primitive: {
                        topology : 'triangle-list',          
                    },

                    cullMode: 'none',               // new: remove optimisation for culling

                    depthStencil: depthStencilState,
                });

                console.log('Creating Render Pass Descriptor...');
                renderPassDescriptor = {
                    label: 'Basic canvas render pass',
                    colorAttachments: [{
                        // view: <- to be filled out when we render
                        clearValue: [1.0, 0.75, 0.60, 1.0],
                        loadOp: 'clear',  // clear or store (draw on top)
                        storeOp: 'store', // store or clear (throw away - e.g. multisampling)
                    }],
                    depthStencilAttachment: depthStencilAttachment,
                };

            }}

            async function startup(){
                console.log("Doing all the loading...")
  
                // Load shaders from file
                console.log("Loading Shader files...")
                $.ajax({
                    type: "GET",
                    url: "shaders/15_simple_vs.wgsl",
                    async: false,
                    success: function(response) { vsShaderFile = response; }
                 });
                 $.ajax({ 
                    type: "GET",
                    url: "shaders/15_simple_fs.wgsl",
                    async: false,
                    success: function(response) { fsShaderFile = response; }
                 });

                vsModule = device.createShaderModule({
                    label: 'Simple VS ',
                    code: vsShaderFile,
                });
                fsModule = device.createShaderModule({
                    label: 'Simple FS ',
                    code: fsShaderFile,
                });

                console.log('Creating layout for Group...');
                bindGroupLayout = device.createBindGroupLayout({       
                    entries: [{
                        binding: 0,      // modelMatrix @binding(0)
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {},
                    }, {
                        binding: 1,      // projectionMatrix @binding(1)
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {},
                    }, {
                        binding: 2,      // viewMatrix @binding(2)        
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {},
                    }, {
                        binding: 3,     // sampler @binding(3)
                        visibility: GPUShaderStage.FRAGMENT,
                        sampler: {}
                    }, {
                        binding: 4,     // texture @binding(4)
                        visibility: GPUShaderStage.FRAGMENT,
                        texture: {sampleType: 'float', viewDimension: '2d', multisampled: false,
                    }
                    }]
                });

                console.log('Creating pipeline layout...');
                pipelineLayout = device.createPipelineLayout({          
                    bindGroupLayouts: [
                        bindGroupLayout, // @group(0)
                    ]
                });


                canvasWidth = canvas.width;
                canvasHeight = canvas.height;
                create_pipeline();
    
                console.log("Gathering vertex, color, index, transformation data...");
                // Load geomtery
                const vertexData = new Float32Array([
                    // Note: using expanded vertex data for each face as we need to assign a color/normal to each vertex for each size
                    // front face
                    -1.0,  1.0,  1.0,
                    -1.0, -1.0,  1.0,
                     1.0,  1.0,  1.0,
                     1.0, -1.0,  1.0,
                    // right face
                     1.0,  1.0, -1.0,
                     1.0,  1.0,  1.0,
                     1.0, -1.0, -1.0,
                     1.0, -1.0,  1.0,
                    // back face
                     1.0,  1.0, -1.0,
                     1.0, -1.0, -1.0,
                    -1.0,  1.0, -1.0,
                    -1.0, -1.0, -1.0,
                    // left face
                    -1.0,  1.0,  1.0,
                    -1.0,  1.0, -1.0,
                    -1.0, -1.0,  1.0,
                    -1.0, -1.0, -1.0,
                    // bottom face
                     1.0, -1.0,  1.0,
                    -1.0, -1.0,  1.0,
                     1.0, -1.0, -1.0,
                    -1.0, -1.0, -1.0,
                    // top face
                    -1.0,  1.0,  1.0,
                     1.0,  1.0,  1.0,
                    -1.0,  1.0, -1.0,
                     1.0,  1.0, -1.0,
                ]);

                // load colours
                const colorData = new Float32Array([
                    // front face
                    1.0, 0.0, 0.0, 1.0, // red
                    0.0, 1.0, 0.0, 1.0, // green
                    0.0, 0.0, 1.0, 1.0, // blue
                    1.0, 1.0, 1.0, 1.0, // white
                    // right face
                    0.0, 0.0, 0.0, 0.0, // black
                    1.0, 0.0, 0.0, 1.0, // red
                    0.0, 1.0, 0.0, 1.0, // green
                    0.0, 0.0, 1.0, 1.0, // blue
                    // back face
                    1.0, 1.0, 1.0, 1.0, // white
                    0.0, 0.0, 0.0, 0.0, // black
                    1.0, 0.0, 0.0, 1.0, // red
                    0.0, 1.0, 0.0, 1.0, // green
                    // left face
                    0.0, 0.0, 1.0, 1.0, // blue
                    1.0, 1.0, 1.0, 1.0, // white
                    0.0, 0.0, 0.0, 0.0, // black
                    1.0, 0.0, 0.0, 1.0, // red
                    // bottom face
                    0.0, 1.0, 0.0, 1.0, // green
                    0.0, 0.0, 1.0, 1.0, // blue
                    1.0, 1.0, 1.0, 1.0, // white
                    0.0, 0.0, 0.0, 0.0, // black
                    // top face
                    1.0, 0.0, 0.0, 1.0, // red
                    0.0, 1.0, 0.0, 1.0, // green
                    0.0, 0.0, 1.0, 1.0, // blue
                    1.0, 1.0, 1.0, 1.0, // white
                ]);

                // Load texture coordinates                         // New
                const textureData = new Float32Array([
                    // front face
                    0.0, 1.0, 
                    0.0, 0.0,
                    1.0, 1.0,
                    1.0, 0.0,
                    // right face
                    0.0, 1.0, 
                    1.0, 1.0,
                    0.0, 0.0, 
                    1.0, 0.0,
                    // back face
                    0.0, 0.0, 
                    0.0, 1.0,
                    1.0, 0.0, 
                    1.0, 1.0,
                    // left face
                    0.0, 1.0, 
                    1.0, 1.0,
                    0.0, 0.0, 
                    1.0, .0,
                    // bottom face
                    1.0, 1.0, 
                    0.0, 1.0,
                    1.0, 0.0, 
                    0.0, 0.0,
                    // top face
                    0.0, 0.0, 
                    1.0, 0.0,
                    0.0, 1.0, 
                    1.0, 1.0, 
                ]);

                // Load index Data
                const indexData = new Uint32Array([
                     0,  1,  2,  2,  1,  3,  // front
                     4,  5,  6,  6,  5,  7,  // right
                     8,  9, 10, 10,  9, 11,  // back
                    12, 13, 14, 14, 13, 15,  // left
                    16, 17, 18, 18, 17, 19,  // bottom
                    20, 21, 22, 22, 21, 23,  // top
                ]);

                // Create an ImageBitmap                // New
                let response = await fetch('textures/old-plank-flooring2-bl/old-plank-flooring2b_basecolor.png'); 
                let blob = await response.blob();   // obtaining a Blob from the response
                let imageBitmap = await createImageBitmap(blob); // create an ImageBitmap from the Blob

                // translations     (just random placements - can be done in a better way!) 
                translations.push(vec3.create( 0.0, 0.0,  1.0));       // 0
                translations.push(vec3.create(-3.0, -3.0,  3.0));       // 1
                translations.push(vec3.create( 2.0,  4.0,  5.0));       // 2
                translations.push(vec3.create(-3.0,  1.0,  6.0));       // 3
                translations.push(vec3.create( 4.0, -3.0, 10.0));       // 4
                translations.push(vec3.create(-5.0,  5.0, -9.0));       // 5
                translations.push(vec3.create( 6.0,  2.0, -2.0));       // 6
                translations.push(vec3.create( 0.0,  0.0, -10.0));      // 7
                translations.push(vec3.create( 0.0, -4.0,  5.0));       // 8
                translations.push(vec3.create(-3.0, -3.0, -10.0));      // 9


                // transformation
                for (let i = 0; i < translations.length; i++){
                    let modelMatrix = mat4.create();
                    mat4.identity(modelMatrix);
                    modelMatrix = mat4.translate(modelMatrix, translations[i]);
                    modelMatrix = mat4.rotate(modelMatrix, [1.0, 1.0, 0.0], angle * (Math.PI/180.0) );
                    modelMatrices.push(modelMatrix);
                }

                // Projections
                canvasWidth = canvas.width;
                canvasHeight = canvas.height;
                projectionMatrix = mat4.perspective(60.0 * Math.PI / 180.0, canvasWidth / canvasHeight, 0.1, 1000.0);
                const uniformData1 = projectionMatrix;

                // View
                viewMatrix = mat4.lookAt(
                        cameraPosition, 
                        vec3.add(cameraPosition, cameraFront),
                        cameraUp);

                console.log("Creating Buffers...");
                vertexBuffer = device.createBuffer({
                    label: 'vertex buffer object',
                    size: vertexData.byteLength,
                    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                });
                device.queue.writeBuffer(vertexBuffer, 0, vertexData);

                colorBuffer = device.createBuffer({
                    label: 'color attribute object',
                    size: colorData.byteLength,
                    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                });
                device.queue.writeBuffer(colorBuffer, 0, colorData);

                textureBuffer = device.createBuffer({               // New
                    label: 'texture buffer',
                    size: textureData.byteLength,
                    usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
                });
                device.queue.writeBuffer(textureBuffer, 0, textureData);

                indexBuffer = device.createBuffer({
                    label: 'index buffer',
                    size: indexData.byteLength,
                    usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
                });
                device.queue.writeBuffer(indexBuffer, 0, indexData);

                for (let i = 0; i < translations.length; i++){
                    let uniformBuffer = device.createBuffer({            
                        label: 'uniform buffer',
                        size: modelMatrices[i].byteLength,
                        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                    });
                    device.queue.writeBuffer(uniformBuffer, 0, modelMatrices[i]);

                    uniformBufferTransformations.push(uniformBuffer);
                }
     
                uniformBufferProjection = device.createBuffer({           
                    label: 'uniform buffer',
                    size: projectionMatrix.byteLength,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                });
                device.queue.writeBuffer(uniformBufferProjection, 0, projectionMatrix);

                uniformBufferView = device.createBuffer({           
                    label: 'uniform buffer',
                    size: viewMatrix.byteLength,
                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
                });
                device.queue.writeBuffer(uniformBufferView, 0, viewMatrix);

                // Create a texture                         // New
                texture = device.createTexture({
                    size: [imageBitmap.width, imageBitmap.height],
                    format: 'rgba8unorm',
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT
                });
                device.queue.copyExternalImageToTexture(            // Similar to writeBuffer but for textures
                    { source: imageBitmap },
                    { texture: texture },
                    [imageBitmap.width, imageBitmap.height]
                );

                // Create a sampler                         // New
                const sampler = device.createSampler({
                    magFilter: 'linear',
                    minFilter: 'linear',
                });
                
                // create bind group with the resources
                // note: layout and binding can't be changed without redoing the pipeline, resources can be updated.
                console.log('Creating bind groups...');
                
                for (let i = 0; i < translations.length; i++){

                    let bindGroup = device.createBindGroup({
                        layout: bindGroupLayout,
                        entries: [{
                                binding: 0,
                                resource: { buffer: uniformBufferTransformations[i] }                
                            }, {
                                binding: 1,
                                resource: { buffer: uniformBufferProjection }
                            }, {
                                binding: 2,
                                resource: { buffer: uniformBufferView }
                            },{
                                binding: 3, 
                                resource: sampler               // New
                            },{
                                binding: 4,                     // New
                                resource: texture.createView({
                                    dimension: '2d',
                                })      
                            }]
                    });
                    bindGroups.push(bindGroup);
                }
                
            
                console.log('Finish all loading at startup...');
            }


            function render() {
                // Calculate FPS
                now = Date.now();
                const deltaTime = now - then;
                let fps = (1000.0 / (deltaTime));
                then = now;
                //console.log("Rendering frame (" + Date().toLocaleString() + ") at " + fps.toFixed(2) +" FPS.");

                // Update render settings here.....
                projectionMatrix = mat4.perspective(60.0 * Math.PI / 180.0, canvasWidth / canvasHeight, 0.1, 1000.0);
                device.queue.writeBuffer(uniformBufferProjection, 0, projectionMatrix);

                // Update key presses
                cameraSpeed = 0.02 * deltaTime;
                for (var key in keys){
                    if (key == 38) cameraPosition = vec3.add(cameraPosition, vec3.mulScalar(cameraFront, cameraSpeed));
                    if (key == 40) cameraPosition = vec3.subtract(cameraPosition, vec3.mulScalar(cameraFront, cameraSpeed));
                    if (key == 37) cameraPosition = vec3.subtract(cameraPosition, vec3.mulScalar(vec3.normalize(vec3.cross(cameraFront, cameraUp)), cameraSpeed));
                    if (key == 39) cameraPosition = vec3.add(cameraPosition, vec3.mulScalar(vec3.normalize(vec3.cross(cameraFront, cameraUp)), cameraSpeed));
                }

                viewMatrix = mat4.lookAt(
                        cameraPosition, 
                        vec3.add(cameraPosition, cameraFront),
                        cameraUp);
                device.queue.writeBuffer(uniformBufferView, 0, viewMatrix);
                
                // Get the current texture from the canvas context and set it as the texture to render.
                renderPassDescriptor.colorAttachments[0].view =
                    context.getCurrentTexture().createView();

                const encoder = device.createCommandEncoder({ label: 'the encoder' });
                const pass = encoder.beginRenderPass(renderPassDescriptor);
                pass.setViewport(0, 0, canvasWidth, canvasHeight, 0, 1);   
                pass.setPipeline(pipeline);

                for (let i = 0; i < translations.length; i++){
                    pass.setBindGroup(0, bindGroups[i]);            

                    angle = angle + 0.1;        // create some simple animation
                    let modelMatrix = mat4.create();
                    mat4.identity(modelMatrix);
                    modelMatrix = mat4.translate(modelMatrix, translations[i]);
                    modelMatrix = mat4.rotate(modelMatrix, [1.0, 1.0, 0.0], angle * (Math.PI/180.0) );
                    modelMatrices[i] = modelMatrix;
                    device.queue.writeBuffer(uniformBufferTransformations[i], 0, modelMatrices[i]);
                    
                    pass.setVertexBuffer(0, vertexBuffer);      // Set WebGPU using VBO
                    pass.setVertexBuffer(1, colorBuffer);       // Set WebGPU using colors
                    pass.setVertexBuffer(2, textureBuffer);     // Set WebGPU using texture coordinates
                    pass.setIndexBuffer(indexBuffer, 'uint32'); // Set WebGPU using index data
                    pass.drawIndexed(36);           // draw with indices
                }

                pass.end();
                
                const commandBuffer = encoder.finish();
                device.queue.submit([commandBuffer]);
                
                // Option 2 loop: 
                //requestAnimationFrame(render);  
            }

            // start code
            await setup();
            await startup();
            
            // Option 1 loop: define FPS
            const UPDATE_INTERVAL = 1000.0 /30.0; 
            setInterval(render, UPDATE_INTERVAL);
    
            // Option 2 loop: match display rate
            //requestAnimationFrame(render);   

            // Check for resize
            const observer = new ResizeObserver(entries => {
                for (const entry of entries) {
                    const canvas = entry.target;
                    const width = entry.contentBoxSize[0].inlineSize;
                    const height = entry.contentBoxSize[0].blockSize;
                    canvas.width = Math.max(1, Math.min(width, device.limits.maxTextureDimension2D));
                    canvas.height = Math.max(1, Math.min(height, device.limits.maxTextureDimension2D));
                    canvasWidth = canvas.width;
                    canvasHeight = canvas.height;

                    // need to recreate pipeline as depth texture will not match size
                    create_pipeline();
                }
            });
            observer.observe(canvas);

            // Check for key presses
            $(document).keydown(function (e) {
                keys[e.which] = true;
            });
            $(document).keyup(function (e) {
                delete keys[e.which];
            });

        } 

        main();

    </script>

</body>
</html>